---
description: Project structure and organization conventions for my-open-claude
alwaysApply: true
---

# my-open-claude Project Structure

This Rust project follows a layered architecture: business logic (`core`), interface (`tui`), and entry point (`main`).

## Standard Directory Layout

```
src/
├── main.rs              # Entry point, CLI parsing, orchestration
├── core/                # Business logic (no UI dependencies)
│   ├── config.rs        # Configuration (env, API)
│   ├── confirm.rs       # Confirmation abstraction (CLI/TUI)
│   ├── credits.rs       # OpenRouter credits fetching
│   ├── message.rs       # API message content extraction
│   ├── paths.rs         # Config/cache/data dir paths
│   ├── persistence.rs   # Persistence (last model used)
│   ├── util.rs          # Generic helpers (filter_by_query)
│   ├── commands.rs      # Slash commands definitions
│   ├── workspace/       # Workspace detection
│   │   └── mod.rs       # Root, project type, AGENTS.md loading
│   ├── history/         # Conversation persistence
│   │   ├── mod.rs       # Public API, sanitize, filter
│   │   └── storage.rs   # Index/conv file I/O
│   ├── llm/             # Agent loop, chat, streaming
│   │   ├── mod.rs       # Chat, chat_resume, public API
│   │   ├── agent_loop.rs# Streaming loop, tool dispatch
│   │   ├── context.rs   # Token estimate, truncation
│   │   ├── tool_execution.rs  # Single tool call execution
│   │   ├── error.rs     # LLM error types
│   │   └── stream.rs    # Stream chunk parsing
│   ├── models/          # Model discovery, filtering, caching
│   │   ├── mod.rs       # Public re-exports
│   │   ├── info.rs      # ModelInfo struct
│   │   ├── cache.rs     # 24h disk cache
│   │   └── fetch.rs     # API fetch, filter, resolve
│   └── tools/           # Agent tools
│       ├── mod.rs       # Tool trait, registry, definitions cache
│       ├── bash.rs      # Command execution
│       ├── edit.rs      # Targeted search-and-replace
│       ├── glob_tool.rs # Glob pattern file search
│       ├── grep.rs      # Regex file search
│       ├── ignore.rs    # Dir traversal ignore patterns
│       ├── list_dir.rs  # Directory listing
│       ├── read.rs      # File reading
│       └── write.rs     # File writing
└── tui/                 # Text interface (ratatui)
    ├── mod.rs           # Main loop, credits, pending chat
    ├── app/             # Application state
    │   ├── mod.rs       # App, popups state, ScrollPosition
    │   └── messages.rs  # ChatMessage types
    ├── chat_result.rs   # handle_chat_result, save_conversation_if_dirty
    ├── constants.rs     # UI constants (suggestions, colors, scroll, poll)
    ├── shortcuts.rs     # Keyboard shortcut mapping
    ├── text.rs          # Markdown parsing, line wrapping
    ├── handlers/        # Keyboard/mouse event handling
    │   ├── mod.rs       # Orchestrator, handle_key, handle_mouse
    │   ├── chat_spawn.rs# Spawn chat/chat_resume in background
    │   ├── confirm.rs   # Confirm popup (y/n)
    │   ├── history_selector.rs  # History picker
    │   ├── input.rs     # Main input, send, scroll
    │   ├── model_selector.rs    # Model picker popup
    │   └── shortcuts.rs  # History, NewConv, ModelSelector, Quit keys
    └── draw/            # Widget rendering
        ├── mod.rs       # Layout orchestration
        ├── header.rs    # Logo, title, model, credits
        ├── history.rs   # Chat history with scrollbar
        ├── history_selector_popup.rs
        ├── input/       # Input block, suggestions, bottom bar
        │   ├── mod.rs
        │   ├── bar.rs   # Bottom bar
        │   └── slash.rs # Slash command autocomplete
        ├── popups.rs    # Confirm popup, model selector popup
        └── welcome_mascot.rs
```

## Dependency Rules

1. **core/** must never import `tui` or `main`. It is UI-independent.
2. **tui/** may import `core`. Not the reverse.
3. **main.rs** orchestrates entry (CLI vs TUI) and imports both `core` and `tui`.

## Where to Place New Code

| Type of code | Location |
|--------------|----------|
| Business logic, API access, data models | `core/` |
| New agent tool | `core/tools/<name>.rs` |
| LLM / agent logic | `core/llm/` |
| New models submodule | `core/models/<name>.rs` |
| Persistence (index, files) | `core/history/storage.rs` |
| Rendering, widgets, layout | `tui/draw/` |
| Event handling (keyboard, mouse) | `tui/handlers/` |
| Chat result handling, save logic | `tui/chat_result.rs` |
| App state, message structures | `tui/app/` |
| CLI parsing, orchestration | `main.rs` |

## Rust Conventions

- One module per file; `mod.rs` re-exports submodules.
- Error types specific to a domain: `core/llm/error.rs`.
- Document modules with `//!` at the top of the file.
- Shared helpers stay in the relevant module or a dedicated submodule.

## SOLID Principles

- **S (Single Responsibility)**: One module/struct = one clear purpose. Extract policies (output limits, Ask-mode restrictions) into dedicated modules.
- **O (Open/Closed)**: Extend via `impl Trait` rather than modifying existing code. New tools = `impl Tool` without touching `tool_execution`. Prefer trait methods (`output_limit()`, `disabled_in_ask_mode()`) over hard-coded `match` on tool names.
- **L (Liskov Substitution)**: Any trait implementation must be substitutable. Ensure `Tool::execute` and similar methods honor their contract.
- **I (Interface Segregation)**: Keep traits small and focused (e.g. `ConfirmDestructive` as a closure, not a heavy interface).
- **D (Dependency Inversion)**: Depend on abstractions (traits), not concrete types. Prefer injecting `tools_list` into `ChatRequest` over calling `tools::all()` from the LLM layer.

## File Length Guidelines

- **~250 lines**: Consider extracting cohesive blocks into a submodule (e.g. `handle_model_selector`, `handle_history_selector`).
- **~400 lines**: Extract logic into a submodule to keep files focused.
- Extract when a file mixes distinct responsibilities (e.g. handlers: shortcuts vs popups vs input).
